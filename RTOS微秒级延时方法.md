# RTOS微秒级延时

系统滴答本质是一个定时器中断，每隔一定时间触发一次，它就像是RTOS的心跳。

系统滴答在RTOS的功能

​	1.系统滴答每次触发时，RTOS会根据调度机制检查是否需要任务切换。

​	2.延时管理：如果滴答间隔是 1ms，vTaskDelay(10) 会让任务暂停 **10ms**。

​	3.定时器、信号量等待超时、任务阻塞超时等功能都依赖滴答计数。

通常RTOS的系统滴答是1khz，当然也有100hz或10khz的情况。举例一些常见的RTOS情况。

​	**1.FreeRTOS**

​	默认SysTick为1000HZ（即 configTICK_RATE_HZ = 1000），可配置更低的频率来降低功耗。

​	**2.RT-Thread**

​	默认SysTick为1000HZ（即 RT_TICK_PER_SECOND = 1000），可配置更低的频率来降低功耗。

​	**3.μC/OS-II/III**

​	默认SysTick为10-100HZ（即OS_TICKS_PER_SEC = 10–100）

系统滴答的选择根据以下几点：

​	1.实时性：高实时性系统（电机控制）需要短滴答周期，一般<1ms；低实时系统（传感器次采集）可放宽10-100ms。

​	2.功耗优化：电池供电设备（LOT设备）降低滴答频率，减少CPU唤醒次数。

​	3.任务切换开销：高频滴答可能导致过多上下文切换。

​	4.某些MCU的定时器精度或中断处理能力可能限制滴答频率。



#### 1000hz时，系统最短延时为1ms，在实时控制中有些情况需要微秒级延时，该怎么办？

​	两种思路：

​	1.酌情提高系统时钟

​	2.使用MCU的高精度定时器

#### 1、酌情提高系统时钟

​	因为系统时钟越快，单位时间内的线程调度次数越多，功耗也随之增加

#### 2、使用MCU片上外设

​	一般MCU都会有片上高精度定时器外设，可以配置到1us,使用其不只是开启定时器这么简单，**RTOS要实现的是阻塞延时，任务进入延时后要交出CPU的控制权**，进入死等状态，这对于RTOS是不好的，需要进入睡眠让权状态才是最好的。另外在一个线程处于延时中断时另一个线程又开始延时了有可能发生重入现象或时间覆盖现象。

​	要在 RTOS 中实现 **非阻塞、高精度、多任务安全** 的 1μs 级延时，需结合 **硬件定时器中断** 和 **RTOS 任务管理机制**。

#### 3、空循环延时

​	通过精确计算CPU指令周期，用空循环实现微秒级延时。

```
// 基于CPU主频的空循环延时（72MHz主频示例）
void delay_us(uint16_t us) {
  uint32_t cycles = us * 72;  // 72MHz → 72 cycles/μs
  for (volatile uint32_t i = 0; i < cycles; i++);
}
```

对于第二种情况使用高精度定时器，要实现阻塞式延时：

​	1.使用高精度定时器加队列加任务通知

​	2.使用高精度定时器加加队列信号量

### **1. 为什么不能直接“裸用”硬件定时器？**

​	（1）若直接通过硬件定时器实现 **忙等待**（如循环读取计数器），任务会持续占用 CPU.

​	  (2) 多任务冲突

​		重入问题**：若多个任务同时调用 `delay_us()`，可能竞争同一硬件定时器资源，导致计时混乱。**

​		中断覆盖：频繁修改定时器配置（如重设计数值）可能打断正在进行的延时操作。